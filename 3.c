#include <stdio.h>

// классическое решение рекурсией, но при n > 42 выходит за 1с
// int fib(int n) {
//     if (n == 0) return 0;
//     if (n == 1 || n == 2) return 1;
//     return fib(n - 1) + fib(n - 2);
// }

// более оптимизированное решение
int fib(int n) {
    // сразу делаем возврат, так как это значение мы знаем
    if (n <= 0) return 0;

    // создаём переменные:
    // 1) prev_f для числа перед последним посчитанным (изначально равен 0, так как curr_n = 1)
    // 2) curr_f для последнего посчитанного числа (изначально равен 1, так как curr_n = 1)
    // 3) curr_n для номера n последнего посчитанного числа (изначально равен 1, ведь нужно хранить 2 значения)
    // 4) temp для временного хранения prev_f при посчёте нового curr_f
    int prev_f = 0, curr_f = 1, curr_n = 1, temp;
    // выполняем цикл (просчёт новых чисел), пока не досчитаем до n-ного числа
    while (curr_n < n) {
        // считаем новое число как сумму 2 предыдущих и обновляеим переменны prev_f и curr_f
        temp = prev_f;
        prev_f = curr_f;
        curr_f = temp + prev_f;
        // мы посчитали новое число, обновляем curr_n
        curr_n++;
    }
    // возвращаем последнее посчитанное число (идеально до него считали)
    return curr_f;
}

int main() {
    // создаём переменную с числом n и вводим его
    int n;
    scanf("%d", &n);
    // с помощью функции считаем n-ое число фибоначчи и выводим его
    printf("%d", fib(n));
    return 0;
}
